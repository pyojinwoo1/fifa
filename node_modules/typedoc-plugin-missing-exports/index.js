"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.discoverMissingExports = exports.load = void 0;
const typedoc_1 = require("typedoc");
function load(app) {
    app.options.addDeclaration({
        name: "internalModule",
        help: "Define the name of the module that internal symbols which are not exported should be placed into.",
        defaultValue: "<internal>",
    });
    const knownPrograms = new Map();
    app.converter.on(typedoc_1.Converter.EVENT_CREATE_DECLARATION, (context) => {
        if (context.scope.kindOf(typedoc_1.ReflectionKind.Project | typedoc_1.ReflectionKind.Module)) {
            knownPrograms.set(context.scope, context.program);
        }
    });
    app.converter.on(typedoc_1.Converter.EVENT_RESOLVE_BEGIN, onResolveBegin.bind(void 0, knownPrograms), void 0, 1e9);
}
exports.load = load;
function onResolveBegin(knownPrograms, context) {
    const modules = context.project.getChildrenByKind(typedoc_1.ReflectionKind.Module);
    if (modules.length === 0) {
        // Single entry point, just target the project.
        modules.push(context.project);
    }
    for (const mod of modules) {
        let missing = discoverMissingExports(mod);
        if (missing.size === 0)
            continue;
        // Nasty hack here that will almost certainly break in future TypeDoc versions.
        context.setActiveProgram(knownPrograms.get(mod));
        const internalNs = context
            .withScope(mod)
            .createDeclarationReflection(typedoc_1.ReflectionKind.Module, void 0, void 0, context.converter.application.options.getValue("internalModule"));
        context.finalizeDeclarationReflection(internalNs);
        const internalContext = context.withScope(internalNs);
        // Keep track of which symbols we've tried to convert. If they don't get converted
        // when calling convertSymbol, then the user has excluded them somehow, don't go into
        // an infinite loop when converting.
        const tried = new Set();
        do {
            for (const s of missing) {
                if (shouldConvertSymbol(s, context.checker)) {
                    internalContext.converter.convertSymbol(internalContext, s);
                }
                tried.add(s);
            }
            missing = discoverMissingExports(internalNs);
            for (const s of tried) {
                missing.delete(s);
            }
        } while (missing.size > 0);
        // All the missing symbols were excluded, so get rid of our namespace.
        if (!internalNs.children?.length) {
            context.project.removeReflection(internalNs);
        }
        context.setActiveProgram(void 0);
    }
    knownPrograms.clear();
}
function discoverMissingExports(root) {
    const missing = new Set();
    const queue = [];
    let current = root;
    const visitor = (0, typedoc_1.makeRecursiveVisitor)({
        reference(type) {
            if (!type.reflection) {
                const symbol = type.getSymbol();
                if (symbol) {
                    missing.add(symbol);
                }
            }
        },
        reflection(type) {
            queue.push(type.declaration);
        },
    });
    const add = (item) => {
        if (!item)
            return;
        if (item instanceof typedoc_1.Reflection) {
            queue.push(item);
        }
        else {
            queue.push(...item);
        }
    };
    do {
        // Ugly? Yeah, it is. TypeDoc doesn't have a "visit all types" function,
        // so we have to build our own. This is modeled after the one in
        // https://github.com/TypeStrong/typedoc/blob/beta/src/lib/validation/exports.ts
        if (current instanceof typedoc_1.ContainerReflection) {
            add(current.children);
        }
        if (current instanceof typedoc_1.DeclarationReflection) {
            current.type?.visit(visitor);
            add(current.typeParameters);
            add(current.signatures);
            add(current.indexSignature);
            add(current.getSignature);
            add(current.setSignature);
            current.overwrites?.visit(visitor);
            current.inheritedFrom?.visit(visitor);
            current.implementationOf?.visit(visitor);
            current.extendedTypes?.forEach((type) => type.visit(visitor));
            // do not validate extendedBy, guaranteed to all be in the documentation.
            current.implementedTypes?.forEach((type) => type.visit(visitor));
            // do not validate implementedBy, guaranteed to all be in the documentation.
        }
        if (current instanceof typedoc_1.SignatureReflection) {
            add(current.parameters);
            add(current.typeParameters);
            current.type?.visit(visitor);
            current.overwrites?.visit(visitor);
            current.inheritedFrom?.visit(visitor);
            current.implementationOf?.visit(visitor);
        }
        if (current instanceof typedoc_1.ParameterReflection) {
            current.type?.visit(visitor);
        }
        if (current instanceof typedoc_1.TypeParameterReflection) {
            current.type?.visit(visitor);
            current.default?.visit(visitor);
        }
    } while ((current = queue.shift()));
    return missing;
}
exports.discoverMissingExports = discoverMissingExports;
function shouldConvertSymbol(symbol, checker) {
    while (symbol.flags & typedoc_1.TypeScript.SymbolFlags.Alias) {
        symbol = checker.getAliasedSymbol(symbol);
    }
    // We're looking at an unknown symbol which is declared in some package without
    // type declarations. We know nothing about it, so don't convert it.
    if (symbol.flags & typedoc_1.TypeScript.SymbolFlags.Transient) {
        return false;
    }
    // This is something inside the special Node `Globals` interface. Don't convert it
    // because TypeDoc will reasonably assert that "Property" means that a symbol should be
    // inside something that can have properties.
    if (symbol.flags & typedoc_1.TypeScript.SymbolFlags.Property && symbol.name !== "default") {
        return false;
    }
    return true;
}
//# sourceMappingURL=index.js.map